<!doctype html><meta charset=utf-8>

<div style=display:none;>
	<canvas width=32 height=32 id=$canvas></canvas>
	<svg id=$svg fill="inherit" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg">
		<marker
			id="dot"
			orient="auto"
			viewBox="-8 -8 16 16"
			markerWidth="2"
			markerHeight="2"
			refX="0"
			refY="0"
		>
			<line x1="0" y1="0" x2="0" y2="8" stroke="red" />
			<circle r="2" stroke="blue" />
		</marker>
	</svg>
</div>

<style>
	html, body {
		position: fixed;
		margin: 0;
		width: 100%;
		height: 100%;
	}
	#\$box {
		display: grid;
		width: 100%;
		height: 100%;
		grid-area: box;
	}
	#\$pics {
		display: grid;
	}
	#\$pics > *:nth-child(3n+1) {
		grid-area: 1/1/1/1;
	}
	#\$pics > *:nth-child(3n+2) {
		grid-area: 2/1/2/1;
	}
	#\$pics > *:nth-child(3n+3) {
		grid-area: 3/1/3/1;
	}
	#\$pics > *:nth-child(n+4) {
		mix-blend-mode: difference;
	}
	#\$orig {
		display: grid;
		width: 100%;
		height: 100%;
		grid-area: orig;
	}
	#\$box > * {
		grid-area: 1/1/1/1;
	}
	#\$list {
		overflow-y: scroll;
		display: flex;
		flex-flow: row wrap;
		align-content: flex-start;
		grid-area: layers;
	}
	body {
		display: flex;
		flex-flow: column;
	}
	main {
		display: grid;
		grid-template:
			"orig layers" 1fr
		/ 180px 1fr;
		flex: 0mm; min-height: 0;
	}
	drag-item {
		border: 2px outset salmon;
		height: 72px;
		display: grid;
		grid-template:
			"svg row1" 20px
		"svg row2" 1fr
		/ 72px 1fr;
		grid-auto-flow: row;
		place-items: center start;
		background-image: var(--bitmap);
		background-size: auto 100%;
	}
	drag-item > div{
		display: flex;
		flex-flow: row;
	}
	label {
		position: relative;
		width: 1em;
		height: 100%;
		user-select: none;
	}
	label > * {
		display: block;
		box-sizing: border-box;
		margin: 0;
		width: 100%;
		height: 100%;
	}
	input[type=checkbox] {
		appearance: none;
		opacity: 0;
		cursor: pointer;
		touch-action: manipulation;
		position: absolute;
	}
	label > input[type=checkbox] + span {
		text-align: center;
		color: gray;
		background: lavender;
	}
	label > input[type=checkbox]:checked + span {
		font-weight: bold;
		background: #2A2;
		color: white;
	}
	label > input[type=checkbox]:checked[name=male] + span {
		background: #44B;
	}
	label > input[type=checkbox]:checked[name=female] + span {
		background: #C48;
	}
	svg {
		background: white;
	}
	drag-item > svg *[fill^="{"] {
		stroke: red;
	}
	drag-item > svg {
		width: 72px;
		height: 72px;
		grid-area: svg;
		paint-order: stroke;
		stroke: black;
	}
	li {
		flex: none;
		width: 150px;
		height: 90px;
		display: block;
		margin: 0;
		padding: 0;
	}
	li.drop {
		background: #FF02;
		outline: 2px dotted yellow;
		outline-offset: -2px;
	}
	li.drop > * {
		opacity: 0.5;
	}
	drag-item.dragging {
		outline: 2px dotted yellow;
		outline-offset: -2px;
	}
	
</style>

<div><input id=$load><button onclick='go($load.value)'>Load</button></div>
<main>
	<div id=$pics></div>
	<ol id=$list></ol>
</main>

<script>
	/*document.ondragover = ev=>{
		if (ev.dataTransfer.types.includes("Files")) {
			ev.preventDefault()
			ev.dataTransfer.dropEffect = 'copy'
		}
	}
	document.ondrop = ev=>{
		if (ev.dataTransfer.files.length) {
			ev.preventDefault()
			upload(ev.dataTransfer.files)
		}
	}*/
	
	function clean_rows() {
		let layers = {neutral:[],male:[],female:[]}
		for (let x of $list.children) {
			let q = x.firstElementChild
			let path = q.firstElementChild.firstElementChild
			for (let g of q.querySelectorAll('input[type=checkbox]')) {
				if (g.checked)
					layers[g.name].unshift(path.cloneNode(true))
			}
		}
		$svg[0].replaceChildren(...layers.neutral)
		$svg[1].replaceChildren(...layers.male)
		$svg[2].replaceChildren(...layers.female)
	}
	
	let dragging
	function dropzone(cell) {
		let n = false
		cell.ondragover = ev=>{
			ev.dataTransfer.dropEffect = 'move'
			ev.preventDefault()
		}
		cell.ondrop = ev=>{
			if (dragging && ev.dataTransfer.getData('text/x-drag')) {
				cell.classList.remove('drop')
				dragging.classList.remove('dragging')
				let d = dragging
				dragging = null
				let p = d.parentNode
				if (cell.firstChild) {
					if (!p) return
					p.append(cell.firstChild)
				}
				cell.append(d)
				window.setTimeout(x=>clean_rows($list), 0)
			} else {
				console.log('idk?', ev, dragging)
			}
		}
		cell.ondragenter = ev=>{
			if (dragging && ev.dataTransfer.getData('text/x-drag')) {
				if (cell.contains(ev.relatedTarget))
					return
				cell.classList.add('drop')
				ev.preventDefault()
			}
		}
		cell.ondragleave = ev=>{
			if (cell.contains(ev.relatedTarget))
				return
			cell.classList.remove('drop')
		}
	}
	document.ondragend = ev=>{
		if (dragging) {
			dragging.classList.remove('dragging')
			dragging = null
		}
	}
	$list.ondragstart = ev=>{
		if (ev.target.tagName=='DRAG-ITEM') {
			dragging = ev.target
			ev.target.classList.add('dragging')
			ev.dataTransfer.setData('text/x-drag', 1)
			ev.dataTransfer.effectAllowed = 'move'
		}
	}
	
	function dlayer(elem, which) {
		let l = document.createElement('drag-item')
		l.setAttribute('draggable', true)
		l.append(elem)
		let gs = ['neutral','male','female'].map(x=>{
			let i = document.createElement('input')
			i.type = 'checkbox'
			i.name = x
			i.checked = x==which
			let l = document.createElement('label')
			let v = document.createElement('span')
			v.textContent = {neutral:'X',male:'M',female:'F'}[x]
			l.prepend(i,v)
			return l
		})
		let c = document.createElement('div')
		c.append(...gs)
		l.append(c)
		
		let m = document.createElement('li')
		dropzone(m)
		m.append(l)
		
		return m
	}
	
	function load(file) {
		let x = new XMLHttpRequest()
		x.open('GET', file, false)
		x.send()
		return x.responseXML
	}
	
	function set_gender(layer, gender) {
		let c = layer.querySelector('input[name='+gender+']')
		c.checked = true
	}
	
	function fmt(w) {
		return Math.round(w/1e2)/1e3
	}
	function rnd(w) {
		return w*1e5
	}
	
	function convertToAbsolute(path){
		let segs = path.pathSegList
		let outs = [], out = ""
		let x=0, y=0
		let x0=0, y0=0
		for (let i=0,len=segs.numberOfItems; i<len; ++i){
			let s = segs.getItem(i)
			let c = s.pathSegTypeAsLetter
			let ox = 0, oy = 0
			if ('mlhvcsqta'.includes(c)) {
				c = c.toUpperCase()
				ox = x, oy = y
			}
			if ('x' in s) x = ox+rnd(s.x)
			if ('y' in s) y = oy+rnd(s.y)
			if (c=='M') {
				x0 = x, y0 = y
				if (out) {
					out += 'z'
					outs.push(out)
					out = ""
				}
			} else if (c=='z' || c=='Z') {
				out += 'z'
				x = x0, y = y0
				if (out) {
					outs.push(out)
					out = ""
				}
				continue
			}
			
			out += c
			if (c=='A')
				out += ' '+fmt(rnd(s.r1))+' '+fmt(rnd(s.r2))+' '+fmt(rnd(s.angle))+' '+s.largeArcFlag+' '+s.sweepFlag
			if ('x1' in s)
				out += ' '+fmt(ox+rnd(s.x1))+' '+fmt(oy+rnd(s.y1))
			if ('x2' in s)
				out += ' '+fmt(ox+rnd(s.x2))+' '+fmt(oy+rnd(s.y2))
			if ('x' in s)
				out += ' '+fmt(ox+rnd(s.x))
			if ('y' in s)
				out += ' '+fmt(oy+rnd(s.y))
		}
		if (out) {
			out += 'z'
			outs.push(out)
			out = ""
		}
		return outs
	}
	
	let c2d = $canvas.getContext('2d')
	c2d.scale(c2d.canvas.width / 36, c2d.canvas.height / 36)
	function make_bitmap(shape) {
		c2d.fillStyle = 'white'
		c2d.fillRect(0, 0, 36,36)
		c2d.fillStyle = 'black'
		if (shape.nodeName=='path') {
			let path = new Path2D(shape.getAttribute('d'))
			c2d.fill(path)
		}
		else if (shape.nodeName=='circle') {
			c2d.beginPath()
			c2d.arc(shape.getAttribute('cx')||0, shape.getAttribute('cy')||0, shape.getAttribute('r')||0, 0, Math.PI*2)
			c2d.fill()
		}
		let url = c2d.canvas.toDataURL('image/png', 0.8)
		//console.log(url)
		return url
		//return c2d.getImageData(0,0,c2d.canvas.width,c2d.canvas.height)
	}
	
	function go(name) {
		let n = load('original/'+name+'/neutral.svg')
		let m = load('original/'+name+'/male.svg')
		let f = load('original/'+name+'/female.svg')
		let lists = []
		let layermap = new Map()
		let vars = [n,m,f].map((x,i)=>{
			let gender = ['neutral','male','female'][i]
			x = x.documentElement
			let svg = x
			let j=0
			
			let addshape = (shape,above)=>{
				let key = make_bitmap(shape,above)//shape.outerHTML
				let existing = layermap.get(key)
				j++;
				if (existing) {
					existing._order = j+i/8
					set_gender(existing, gender)
					return
				}
				
				let c = shape.cloneNode(true)
				c._sister = shape.cloneNode(true)
				let svg2 = svg.cloneNode(false)
				svg2.append(c)
				let g = dlayer(svg2,gender)
				g._order = j+i/8
				g.style.setProperty('--bitmap', 'url("'+key+'")')
				lists.push(g)
				//$list.prepend()
				
				layermap.set(key, g)
				
			}
			let children = [...x.children]
			let shape
			while (shape = children.shift()) {
				if (shape.nodeName == 'path') {
					let fill = shape.getAttribute('fill')
					if (fill[0]=='{')
						shape.setAttribute('fill', fill.match(/{(.*?)[|]/)[1])
					let paths = convertToAbsolute(shape)
					for (let path of paths) {
						let n = shape.cloneNode(false)
						n.setAttribute('d', path)
						addshape(n, children)
					}
					continue
				}
				addshape(shape, children)
			}
			return x
		})
		let out = vars.map(x=>x.cloneNode(false))
		lists.sort((a,b)=>{
			return b._order - a._order
		})
		$list.append(...lists)
		
		$pics.append(...vars)
		$pics.append(...out)
		$svg = out
		clean_rows()
	}
</script>
todo:
- diff between orig/edited
- show all gender variants etc.
- color selector, skin colors, predefined palettes

